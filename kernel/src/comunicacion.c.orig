#include "../include/comunicacion.h"

void manejar_consolas(int server_fd){
	while(1) {
        arr_procesos[idProceso] = esperar_cliente(server_fd);
        log_info(logger,"Nuevo proceso recibido");
        server_escuchar(logger, "Consola", arr_procesos[idProceso]);
    }
}


void manejar_cpu(int socket_fd){
    t_procesar_conexion_args* args = malloc(sizeof(t_procesar_conexion_args));
    args->log = logger;
    args->fd = socket_fd;
    // ACA VA LA ESCUCHA DEL KERNEL AL CPU
    manejarConexion(args);
 }

void manejar_memoria(int socket_fd){
    t_procesar_conexion_args* args = malloc(sizeof(t_procesar_conexion_args));
    args->log = logger;
    args->fd = socket_fd;
    // ACA VA LA ESCUCHA DEL KERNEL A LA MEMORIA
    manejarConexion(args);
 }


int manejarConexion(void* void_args){

	t_procesar_conexion_args* args = (t_procesar_conexion_args*) void_args;
    t_log* logger = args->log;
    int socket_cliente = args->fd;
    char* server_name = args->server_name;
    free(args);

	t_list* lista;
	pcb* nodo_pcb;
	while (socket_cliente != -1) {
		op_code cod_op;
		cod_op = recibir_operacion(socket_cliente);

		switch (cod_op) {
		case MENSAJE:
			recibir_mensaje(socket_cliente);
			break;
		case PAQUETE:
			lista = recibir_paquete(socket_cliente);
			log_info(logger, LECTURA_DE_VALORES);
			list_iterate(lista, (void*) iterator);
			break;
		case PAQUETE_CONSOLA:
<<<<<<< HEAD
			recibir_pcb(socket_cliente, &nodo_pcb);
	        list_add(listaNew,nodo_pcb);
	        list_add(listaProcesos,nodo_pcb);
	        log_info(logger,"Se recibiÃ³ un nuevo proceso - PID:%d",idProceso-1);
	        sem_post(&sem_ProcesosNew);
	        //planificar(config_values.algoritmo_planificacion, nodo_pcb);
			//imprimir_PCB(nodo_pcb);
||||||| merged common ancestors
			recv_paquete_consola(socket_cliente, &nodo_pcb);

			planificar(config_values.algoritmo_planificacion, nodo_pcb);

			imprimir_PCB(nodo_pcb);

=======
			recv_paquete_consola(socket_cliente, &nodo_pcb);

			planificar(config_values.algoritmo_planificacion, nodo_pcb);

			// serializar tabla de paginas del PCB a iniciar en memoria
			// inicializar_estructuras_en_memoria(nodo_pcb);

			// imprimir_PCB(nodo_pcb);

>>>>>>> edc41440aab254ce847c3a620d3cac8dd0333e40
			break;
		case PAQUETE_PCB:
			log_debug(logger, RECEPCION_PAQUETE_PCB);
			recv_paquete_pcb(socket_cliente, &nodo_pcb);
<<<<<<< HEAD
			imprimir_PCB(nodo_pcb);
||||||| merged common ancestors
			imprimir_PCB(nodo_pcb);

=======
			// imprimir_PCB(nodo_pcb);

>>>>>>> edc41440aab254ce847c3a620d3cac8dd0333e40
			break;
		case -1:
			log_warning(logger, SERVIDOR_DESCONEXION);
			return EXIT_FAILURE;
		default:
			log_warning(logger,OPERACION_DESCONOCIDA);
			break;
		}
	}
	log_warning(logger, "El cliente se desconecto de %s server", server_name);

	return EXIT_SUCCESS;

}

int server_escuchar(t_log* logger, char* server_name, int client_socket) {
	t_procesar_conexion_args* args = malloc(sizeof(t_procesar_conexion_args));
	args->log = logger;
	args->fd = client_socket;
	args->server_name = server_name;
	manejarConexion(args);
	free(args);
	return EXIT_SUCCESS;
}

<<<<<<< HEAD
void recibir_pcb(int fd, pcb** nodo_pcb){
	recv_paquete_consola(fd, nodo_pcb);
	(*nodo_pcb)->id = idProceso;
	idProceso ++;
	(*nodo_pcb)->estimacion_rafaga = config_values.estimacion_inicial;
}
||||||| merged common ancestors
=======
// Esta funcion notifica a la memoria de un proceso nuevo y envia un pcb para asignar su tabla de paginas
void inicializar_estructuras_en_memoria(pcb* nodo_pcb){
	send_paquete_pcb(conexionAMemoria, nodo_pcb);
}
>>>>>>> edc41440aab254ce847c3a620d3cac8dd0333e40

